
### Distributed ID Generator

1. __场景__
	1. 直观：
		* 用户 id
		* 聊天信息 id
		
2. __需求__
	* 非数字性需求
		1. id作为数据库的主键, 需要保证 __全局唯一__, 数据库会在这个字段上建立  clustered index. 
		2. id要尽可能短，以方便检索以及节省内存. 
		3. 数据查询经常需要根据时间查询，所以可以在时间查询上建立普通索引(secondary index), 但是这个东西的查询效率比不上clustered index。如果能让id按照时间粗略有序，可以省去这个时间字段。之所以不可以做到精确有序，除非用一个但计算法，在分布上场景下做到精确有序性能一般较差. 
	* 数字性需求
		
3. __解决需求__
	1. 算法
		1. UUID: MongoDB会给每一条数据赋予一个唯一的id, 保证不会重复. uuid占据12个字节， 包括4个字节的timestamp, 3个字节的machine id, 2个字节的进程id, 3个字节的计数器。 保证唯一，但是id占的字节太长，占用内存而且查询效率低. 
		2. 多台MySQL: 8台mysql协同工作，第一号id初始值为1, 每次加8 and so on. 使用load balancer在之前负责分布请求到不同的mysql上，可以使用round-robin算法。缺点是id不是严格递增的.
		
