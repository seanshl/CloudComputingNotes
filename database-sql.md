### RDBMS

1. **ACID**
	1. **Atomic**: 每个事务内部所有操作要么全部完成，要么全部不完成
	2. **Consistency:** 任何事务都使数据库从一个有效的状态转换到另一个有效状态
	3. **Isolation**: 并发执行事务的结果与顺序执行事务的结果相同
	4. **Persistency**: 事务提交后，对系统的影响是永久的
2. **包含的技术**  
	1. **Master-Slave Replication**  
  		* 主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现

	2. * ![](https://camo.githubusercontent.com/6a097809b9690236258747d969b1d3e0d93bb8ca/687474703a2f2f692e696d6775722e636f6d2f4339696f47746e2e706e67)  
      1. **Master-Master Replication**![](https://camo.githubusercontent.com/5862604b102ee97d85f86f89edda44bde85a5b7f/687474703a2f2f692e696d6775722e636f6d2f6b7241484c47672e706e67)

	3. 两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。
	
3. __数据库索引原理__
	* 索引原理
		* 回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。
	 * 磁盘I/O与预读
		* 磁盘读取数据时间花费
			1. 寻道时间
				* 磁臂移动到指定磁道位置的时间
				* 5ms以下
			2. 旋转延迟
				* 硬盘转速，例如7200转= 4.17ms
			3. 传输时间
				* 从磁盘读出或者将数据写入磁盘的时间
				* 0.x毫秒，可以忽略不计
			4. 一次磁盘I/O约等于9ms. 
		* 硬件延迟图
			* ![硬件延迟图](http://upload-images.jianshu.io/upload_images/1234352-3f90328d01123407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
		* 磁盘预读
			* 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。
	* 需求： 控制磁盘I/O次数
	* B+树
		1. 结构
			* ![B+树结构](http://upload-images.jianshu.io/upload_images/1234352-5167c6e5d8b28538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
4. **Miscs**
	1. Clustered Index 
		table中数据的physical storage order 与 key的 logic order相同。也就是数据依据聚集索引，可以依次排列在存储硬件上. 一个表中只能有一个clustered index, 一般是做主键，提高查询效率。		

