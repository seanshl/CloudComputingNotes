### RDBMS

1. **ACID**
	1. **Atomic**: 每个事务内部所有操作要么全部完成，要么全部不完成
	2. **Consistency:** 任何事务都使数据库从一个有效的状态转换到另一个有效状态
	3. **Isolation**: 并发执行事务的结果与顺序执行事务的结果相同
	4. **Persistency**: 事务提交后，对系统的影响是永久的
2. **包含的技术**  
	1. **Master-Slave Replication**  
  		* 主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现

	2. * ![](https://camo.githubusercontent.com/6a097809b9690236258747d969b1d3e0d93bb8ca/687474703a2f2f692e696d6775722e636f6d2f4339696f47746e2e706e67)  
      1. **Master-Master Replication**![](https://camo.githubusercontent.com/5862604b102ee97d85f86f89edda44bde85a5b7f/687474703a2f2f692e696d6775722e636f6d2f6b7241484c47672e706e67)

	3. 两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。
	
3. __数据库索引原理__
	* 索引原理
		* 回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。
	 * 磁盘I/O与预读
		* 磁盘读取数据时间花费
			1. 寻道时间
				* 磁臂移动到指定磁道位置的时间
				* 5ms以下
			2. 旋转延迟
				* 硬盘转速，例如7200转= 4.17ms
			3. 传输时间
				* 从磁盘读出或者将数据写入磁盘的时间
				* 0.x毫秒，可以忽略不计
			4. 一次磁盘I/O约等于9ms. 
		* 硬件延迟图
			* ![硬件延迟图](http://upload-images.jianshu.io/upload_images/1234352-3f90328d01123407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
		* 磁盘预读
			* 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。
	* 需求： 控制磁盘I/O次数
	* B+树
		1. 结构
			* ![B+树结构](http://upload-images.jianshu.io/upload_images/1234352-5167c6e5d8b28538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
		2. 解释
			* 浅蓝色块：磁盘块
			* 深蓝色: 数据项
			* 黄色： 指针块. P1表示小于17的磁盘块，P2表示17和35之间的,P3表示大于35的. 
			* 只有leaf存储真实数据，非leaf只存储指引搜索方向的数据.
		3. 查找过程
			* 查找29
			* 首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。
		4. B+树性质
			* 我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。
		5. 多列索引B+树
			* 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

4. **分片**
	1. vertically: 列多的表拆成小表，通过主键联合
	2. 水平:
		 * 表的行数超过2M就会很慢，根据主键进行拆分例如取mod
		 


5. **Miscs**
	1. Clustered Index 
		table中数据的physical storage order 与 key的 logic order相同。也就是数据依据聚集索引，可以依次排列在存储硬件上. 一个表中只能有一个clustered index, 一般是做主键，提高查询效率。		

